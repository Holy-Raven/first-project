### Решенные алгоритмические задачки 

## Экспансия мха
#### Class MossExpansion

Изначально мох занимает одну клетку, через одну минуту он распространяется на все соседние клетки, у каждой клетки есть 4 
соседних клетки. При этом в начальной клетке мох погибает, необходимо вычислить сколько клеток будет заражено мхом через 
заданное количество минут.

#### Входные данные: 
* натуральное число, количество минут.
#### Выходные данные: 
* натуральное число, количество зараженных мхом клеток.
---

## Объединить отсортированный массив
#### Class MergeSortedArray

Вам предоставляются два массива целых чисел nums1 и nums2, отсортированные в порядке неубывания, и два целых числа m и n, 
представляющие количество элементов в nums1 и nums2 соответственно.

Объединить nums1 и nums2 в единый массив, отсортированный в неубывающем порядке.
Окончательный отсортированный массив не должен быть возвращен функцией, но вместо этого должен быть сохранен внутри массива 
nums1. Чтобы учесть это, nums1 имеет длину m + n, где первые m элементы обозначают элементы, которые должны быть объединены, 
а последние n элементы имеют значение 0 и их следует игнорировать. nums2 имеет длину n.

#### Входные данные: 
* nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
#### Выходные данные: 
* [1,2,2,3,5,6]
---

## Удалить элементы массива
#### Class RemoveElement

Учитывая целочисленный массив nums и целое число val, удалите все вхождения val в nums. Порядок элементов может быть изменен. 
Затем верните количество элементов в nums которые не равны val. Учтите количество элементов, в nums которых не равно val равно k.

#### Нужно выполнить следующие действия:
* Измените массив nums таким образом, чтобы первые k элементы nums содержали элементы, которые не равны val. Остальные элементы 
  nums не важны так же, как и размер nums.
* Возврат значения - k.
 
#### Входные данные:
* nums = [3,2,2,3], k = 2
#### Выходные данные:
* Выходные данные - [3,3,0,0]
---

## Удалить дубликаты из массива
#### Class RemoveDuplicates

Учитывая, что массив целых чисел nums отсортирован в неубывающем порядке, удалите дубликаты на месте таким образом, чтобы 
каждый уникальный элемент появлялся только один раз. Относительный порядок элементов должен быть таким же. Затем верните 
количество уникальных элементов в nums.

#### Нужно выполнить следующие действия:
* Измените массив nums таким образом, чтобы первые k элементы nums содержали уникальные элементы в том порядке, в котором 
  они присутствовали nums изначально. Остальные элементы nums не так важны, как размер nums.
* Возврат значения - k.

#### Входные данные:
* nums = [0,0,1,1,1,2,2,3,3,4]
#### Выходные данные:
* Выходные данные - [0,1,2,3,4]
---

## Заполнить двумерный массив по диагонали
#### Class DiagonalFilling

Ёжик решил записать в книжечку натуральные числа на клеточном тетрадном листе по специальному правилу. Он начинает с числа 1 
в левом верхнем углу и затем продолжает по диагонали: справа от первого числа он записывает 2, а под ним - 3. На следующей 
диагонали будут числа 4, 5 и 6, и так далее. Ширина листа составляет n клеток, а высота m клеток. 


#### Нужно выполнить следующие действия:
* показать Ёжику как будут записаны все числа

#### Входные данные:
* n - натуральное число, высота листа.
* m - натуральное число, ширина листа.
#### Выходные данные:
* Выходные данные - двумерный массив чисел заданного формата nums[n][m];
---

## Удалить дубликаты из массива (вариант 2)
#### Class RemoveDuplicatesTwo

Учитывая, что массив целых чисел nums отсортирован в неубывающем порядке, удалите некоторые дубликаты на месте таким образом, 
чтобы каждый уникальный элемент появлялся не более двух раз. Относительный порядок элементов должен быть одинаковым.

#### Нужно выполнить следующие действия:
* После удаления дубликатов остались k элементы, то первые k элементы nums должны содержать конечный результат.
* Возврат значения - k.

#### Входные данные:
* nums = [1,1,1,2,2,3]
#### Выходные данные:
* Выходные данные - [1,1,2,2,3]
---

## Джо покупает пистолет
#### Class JoeBoughtGun

Однажды Джо решил обзавестись револьвером и пришел в оружейный магазин. У ковбоя было s долларов, а на выбор представлены 
n револьверов с a1, a2 ... an ценами. 

#### Нужно выполнить следующие действия:
Помогите купить Джо самый дорогой револьвер, который он может себе позволить, или
сообщите, что такого не существует

#### Входные данные:
* s количество денег которые есть у Джо.
* n целых чисел a - цены револьверов в магазине.
#### Выходные данные:
* m целое число - цену самого дорогого револьвера, который ковбой Джо сможет себе позволить, если такого нет , выведите 0.
---

## Джо собирает "sheriff"
#### Class MadeSheriff

Однажды ковбой Джо нанялся в помощники шерифу. Шериф выдал ковбою Джо строку s и попросил собрать из её букв как можно 
больше слов sheriff. Каждая буква может использоваться не более чем в одном слове. Ковбой Джо тут же приступил к заданию 
шерифа, но к сожалению, он не умеет читать.

#### Нужно выполнить следующие действия:
Помогите ковбою Джо. Выведите на экран число, сколько раз можно собрать слово sheriff из заданной строки.

#### Входные данные:
* s строка состоящая из маленьких букв латинского алфавита
#### Выходные данные:
* n натуральное число - количество слов sheriff, которое можно собрать из букв строки s.
---

## Детектор сбоев:
#### Class FaultDetector 

В мобильное приложение, которое разрабатывает Николай, встроен автоматический детектор сбоев. Когда в приложении возникает 
ошибка, детектор автоматически отправляет сообщение об этом на сервер. Впервые за долгое время Коля решил проверить статистику 
работы своего приложение. Статистика представляет из себя последовательность чисел, каждое из которых равно количеству сообщений 
об ошибках в соответствующий момент работы приложения.

Николай называет сбоем период работы приложения, когда количество ошибок сначала не убывало, а потом не возрастало. 
Например, период работы приложения с количеством ошибок [1,2,4,3,3] является сбоем, а [3,1,2] нет.


#### Нужно выполнить следующие действия:
Коля выбрал m периодов работы приложения и узнал, являются ли эти периоды сбоями в приложении. А сможете ли узнать это вы?

#### Входные данные:
* n - целое число, количество моментов работы приложения для которых записана статистика.
* вторая строка - n целых чисел, количество ошибок в соответствующий момент работы приложения
* m - количество периодов, интересующих Колю
* в следующих m строках описание периодов, которой состоит из двух чисел, номера первого и последнего момента.
#### Выходные данные:
* вывести m строк, каждая из которых соответствует периоду, интересующую Николая. Вывести YES - если указанный период
  является сбоем или NO если нет. 
---

## Общая безопасность кода:
#### Class GeneralCodeSecurity

В компании, где работает Иван, активно применяют различные средства для контроля качества кода. Перед тем, как использовать 
написанную программу, ее код проверяют при помощи N проверок. В качестве результата каждой из проверок дается некоторое 
целое число — опасность кода. Назовем общей опасностью кода сумму опасностей для каждой из проверок.

Иван хочет минимизировать общую опасность написанного кода, для этого он готов не более С раз внести изменения в свой код. 
За одно внесение изменений он может увеличить или уменьшить на D результат одной из проверок, результат остальных проверок 
при этом не поменяется.

#### Нужно выполнить следующие действия:
Помогите Ивану и предложите значения результатов проверок, дающие минимальную общую опасность, которые он может получить, 
сделав не более C изменений.

#### Входные данные:
* n - целое число, количество количеств проверок.
* с - целое число, количество возможных исправлений.
* d - целое число, количество исправлений за один раз.
* строка n целых чисел, результаты проверок до изменений
#### Выходные данные:
* В единственной строке выведите N значений результатов проверок кода после применения не более чем C исправлений. 
  Сумма всех результатов проверок должно быть минимальна.
---

## Мажоритарный элемент:
#### Class MajorityElement

Мажоритарный элемент - это элемент, который появляется более n / 2 раз. Можно предположить, что мажоритарный элемент 
всегда существует в массиве.

#### Нужно выполнить следующие действия:
Учитывая массив nums размера n, верните мажоритарный элемент.

#### Входные данные:
* nums - массив целых чисел.
* n - длина массива.
#### Выходные данные:
* мажоритарное число из заданного массива, если такого нет вывести "0".
---


## Сумма чисел. (арифметическая зависимость)
#### Class SumOfNumbers

Юный Фридрих Гаусс сидел на уроке математики, когда учитель решил дать задание для всего класса, чтобы подольше занять всех учащихся. Для этого он выписал на доске числа ﻿
1﻿,2﻿, ... , ﻿100﻿ и попросил вычислить сумму всех этих чисел.

Недолго думая, Карл Фридрих Гаусс решил задачу почти в ту же секунду, огласив ответ — 5050﻿.

Учителю не понравилось, что юный ученик так быстро справился с заданием, поэтому он сначала стер все числа, но продолжил выписывать на доске ﻿
100﻿, ﻿101﻿, 102﻿, ... , n﻿ и попросил назвать новую сумму всех выписанных чисел.

Фридрих не растерялся, ведь он уже вывел в голове эту формулу. Не растеряетесь ли вы?

#### Входные данные:
* В единственной строке дано одно целое число ﻿n ﻿(102 ≤ 𝑛 ≤ 1 000 000 000 )
#### Выходные данные:
* Выведите одно целое число — сумму чисел от ﻿ 100﻿ до ﻿n﻿ включительно.
---

## Сумма чисел. (геометрическая зависимость)
#### Class Pandemic

Хетаг подозревает, что заразился неизвестным вирусом. Прямо сейчас он сидит на лекции в университете и активно пытается выздороветь. Нам же известна следующая информация:

1. Вирус очень заразный. Спустя минуту после заражения каждый носитель передает вирус всем людям, сидящим вокруг него и не имеющим иммунитета.
2. Вирус совершенно безобидный. Человек болеет этим вирусом бессимптомно ровно одну минуту, после чего приобретает пожизненный иммунитет.

Аудиторию, в которой проходит лекция, можно представить в виде бесконечной клетчатой сетки, в каждой ячейке которой сидит человек. Изначально Хетаг — единственный носитель вируса во всей аудитории. Соответственно, каждую минуту зараженные люди передают вирус своим соседям (клетки считаются соседними, если соприкасаются по стороне; у каждой клетки ровно 4 соседа), после чего моментально выздоравливают и больше не болеют.

Определите количество зараженных на ﻿n﻿-й минуте лекции.

#### Входные данные:
* Первая и единственная строка содержит целое число ﻿n﻿ (1 ≤ ﻿n﻿ ≤ 100 000 000)﻿ — номер минуты, идущей от начала лекции.
  Для примера, ﻿n=1﻿ означает «первую» минуту, то есть отрезок времени длиной в минуту, начинающийся от самого начала лекции.
#### Выходные данные:
* Выведите единственное число — количество зараженных на ﻿n﻿-й минуте лекции.
---

## Интересные пары чисел
#### Class InterestingPairs

Виктория рассматривает занимательную квадратную двумерную матрицу, которая состоит только из натуральных чисел. Она то и дело суммирует числа в столбцах и строках. Виктория называет пару строки-столбца интересными, если сумма чисел в строке отличается от суммы чисел в столбце не более чем на величину числа на пересечении этих строки и столбца.

Найдите количество интересных пар строка-столбец во всей матрице.

#### Входные данные:
*
В первой строке дано число ﻿n ﻿(1 ≤ n ≤ 1000)﻿ — размер квадратной матрицы. В последующих ﻿n﻿ строках задано описание матрицы по ﻿n﻿ целых неотрицательных чисел в каждой. Элементы матрицы ﻿𝑎[𝑖][𝑗] лежат в диапазоне 0 ≤ 𝑎[𝑖][𝑗] ≤ 100 000

#### Выходные данные:
* Выведите единственное число — количество зараженных на ﻿n﻿-й минуте лекции.
---

## Задача с графами (первая)
#### Class TSaurus

Система исполнения «T-Saurus» разработана для параллельного выполнения процессов. Инженеры самой высокой квалификации разработали её таким образом, что одновременно может исполняться бесконечное количество процессов, т. е. вместимость исполнителя не ограничена. Причем, после запуска процесса он успешно завершается ровно через одну секунду.

Несмотря на невероятную эффективность параллелизации, некоторые процессы не могут быть начаты, пока другие не завершат своё исполнение (так часто бывает в реальных системах, когда один процесс использует результаты работы другого и соответственно не может быть запущен с ним параллельно). При этом один процесс может ожидать завершения нескольких процессов.

Все процессы в системе пронумерованы от ﻿1﻿ до n﻿. Для каждого процесса известно, результаты работы каких процессов ему потребуются для исполнения. Ваша задача состоит в том, чтобы определить, за какое минимальное количество секунд могут быть исполнены все процессы.

Гарантируется, что отсутствуют циклические зависимости, и процессы завершатся за конечное время. Также гарантируется, что процесс с номером ﻿1﻿ всегда будет завершаться последним.

#### Входные данные:
* В первой строке дано число ﻿n﻿ (1 ≤ n ≤ 100 000)﻿ — количество процессов. Далее дано ﻿n﻿ строк. В ﻿i﻿-й строке первым числом идёт ﻿𝑎[𝑖] — количество необходимых ﻿i﻿-му процессу процессов для старта. Далее идет ﻿𝑎[𝑖]﻿ чисел через пробел — их номера.
#### Выходные данные:
* В единственной строке выведите количество секунд — минимальное время, за которое все процессы смогут завершиться.
---

## Задача с графами (вторая)
#### Class TSaurusLevels

В предыдущей задаче была рассмотрена система исполнения процессов «T-Saurus». В этой задаче вам предстоит реализовать core-функционал этой системы. Вместо минимального времени, за которое могут быть выполнены все процессы, вам необходимо перечислить их порядок, при котором достигается это время.

Для этого вам необходимо разбить все процессы на непересекающиеся множества процессов (пронумеруем их от ﻿1﻿ до k﻿) так, чтобы сначала исполнитель «T-Saurus» параллельно выполнил все процессы первого множества, затем второго множества и т.д., и исполнение процессов удовлетворяло условию из предыдущей задачи. Т. е. в ﻿i﻿-ом множестве процессов должны присутствовать только те процессы, для которых все необходимые для их исполнения процессы включены в множествах с меньшими номерами ﻿j﻿: ﻿1≤j<i﻿. Напоминаем, что функционал системы «T-Saurus» состоит в том, что при последовательном исполнении предыдущих множеств процессов, все процессы в очередном множестве смогут исполниться.

Входные данные совпадают с входными данными из предыдущей задачи. Обратите внимание на то, как должно выводиться каждое множество — все процессы в рамках множества должны быть отсортированы.
#### Входные данные:
* В первой строке дано число ﻿n﻿ ﻿(1 ≤ n ≤ 100 000)﻿ — количество процессов. Далее дано ﻿n﻿ строк. В ﻿i﻿-й строке первым числом идёт ﻿𝑎[𝑖]﻿ — количество необходимых ﻿i﻿-му процессу процессов. Далее идет ﻿𝑎[𝑖] ﻿ чисел через пробел — их номера.
#### Выходные данные:
* В единственной строке выведите число ﻿k﻿ — количество множеств, на которое необходимо разбить все процессы. В следующих k﻿ строках выведите описание этих множеств: первым числом укажите размер множества ﻿k[i] ﻿, а далее через пробел ﻿k[i] чисел в порядке возрастания — номера процессов очередного множества.
---